1. IO模型
   - 阻塞IO
     - 工作线程一直等待fd就绪。
   - 非阻塞IO
     - 不用等，马上返回一个fd无event。
     - 可能需要工作线程重复获取才能得到一个fd event。
   - 多路复用IO
     - 不用等，马上返回一个fd无event
     - 有一个专门的线程去轮询所有无event的df，询问到有event才调用实际的IO操作
       - 该线程在内核，效率比用户线程高得多
       - 因为只有一个线程处理IO，当响应体很大时会影响整体轮询
     - JAVA NIO使用这个
       - 通过selector.select()去查询每个通道是否有event
       - 无event时会一直阻塞，导致用户线程阻塞
   - 信号驱动IO
     - 用户线程发起IO请求时会注册一个信号函数，然后继续执行
     - 内核数据就绪时发一个信号给用户线程
     - 用户线程调用IO执行实际需要的操作
   - 异步IO
     - 用户线程发起read操作后，可以立即执行其他任务
     - 内核接收到这个read操作请求后，等待数据准备就绪拷贝到用户线程并通知用户线程
     - 用户线程直接读数据
   - 与信号驱动IO的区别
     - 信号驱动IO只是告诉工作线程有IO可用了，实际上工作线程还会去执行IO
     - 异步IO内核已经帮你完成了IO操作，工作线程可以直接拿数据
2. JAVA NIO
   - 三大核心
     - Channel
       - 对比传统IO中的Stream，不同在于Channel是读写双向的
       - 包括FileChannel, DatagramChannel, SocketChannel和ServerSocketChannel
     - Buffer
       - 其实就是一个连续数组，数据存放的容器
       - 一个顶层抽象父类
       - 客户端或者服务端读写总要通过buffer到channel
     - Selector
       - 跟多路复用的内核轮询线程差不多意思，但是这玩意还是属于工作线程，不是内核线程
   - 与传统JAVA IO区别
     - 传统JAVA IO
       - 基于字节流和字符流操作，面向流，阻塞。
       - 要移动流读取数据先要将其缓存到缓冲区
     - NIO
       - 基于Channel和Buffer操作，面向缓冲区，非阻塞。
       - 可以前后移动缓冲区灵活获取需要的数据
         - 灵活移动的前提是，当前缓冲区需要的数据已经处理完毕，否则旧数据会被覆盖
3. 补充-linux 几种多路复用IO
   - select
     - 几乎所有平台支持
     - 有fd限制，32未默认1024,64位默认2048
     - 线性扫描，效率低。
     - 需要维护一个存储大量fd的数据结构，增大了用户空间到内核空间的复制开销
   - poll
     - 与select没有本质区别。
     - 基于链表实现，无fd上限，但是复制开销一样大
     - 水平触发：报告了fd如果没有处理，那么下次poll还会继续报告
   - epoll
     - 2.6内核开始
     - 使用一个fd管理多个fd，无fd上限。利用mmap文件映射减少复制开销
     - 边缘触发：只告诉进程哪些fd就绪，不用轮询，而且只通知一次。